/**
 * Drive
 * Manages files in Drive including uploading, downloading, searching, detecting changes, and updating sharing permissions.
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.2.3.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "File.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

File::File()
{
    m_AppPropertiesIsSet = false;
    m_CapabilitiesIsSet = false;
    m_ContentHintsIsSet = false;
    m_CreatedTime = utility::datetime();
    m_CreatedTimeIsSet = false;
    m_Description = U("");
    m_DescriptionIsSet = false;
    m_ExplicitlyTrashed = false;
    m_ExplicitlyTrashedIsSet = false;
    m_FileExtension = U("");
    m_FileExtensionIsSet = false;
    m_FolderColorRgb = U("");
    m_FolderColorRgbIsSet = false;
    m_FullFileExtension = U("");
    m_FullFileExtensionIsSet = false;
    m_HasAugmentedPermissions = false;
    m_HasAugmentedPermissionsIsSet = false;
    m_HasThumbnail = false;
    m_HasThumbnailIsSet = false;
    m_HeadRevisionId = U("");
    m_HeadRevisionIdIsSet = false;
    m_IconLink = U("");
    m_IconLinkIsSet = false;
    m_Id = U("");
    m_IdIsSet = false;
    m_ImageMediaMetadataIsSet = false;
    m_IsAppAuthorized = false;
    m_IsAppAuthorizedIsSet = false;
    m_Kind = U("");
    m_KindIsSet = false;
    m_LastModifyingUserIsSet = false;
    m_Md5Checksum = U("");
    m_Md5ChecksumIsSet = false;
    m_MimeType = U("");
    m_MimeTypeIsSet = false;
    m_ModifiedByMe = false;
    m_ModifiedByMeIsSet = false;
    m_ModifiedByMeTime = utility::datetime();
    m_ModifiedByMeTimeIsSet = false;
    m_ModifiedTime = utility::datetime();
    m_ModifiedTimeIsSet = false;
    m_Name = U("");
    m_NameIsSet = false;
    m_OriginalFilename = U("");
    m_OriginalFilenameIsSet = false;
    m_OwnedByMe = false;
    m_OwnedByMeIsSet = false;
    m_OwnersIsSet = false;
    m_ParentsIsSet = false;
    m_PermissionIdsIsSet = false;
    m_PermissionsIsSet = false;
    m_PropertiesIsSet = false;
    m_QuotaBytesUsed = U("");
    m_QuotaBytesUsedIsSet = false;
    m_Shared = false;
    m_SharedIsSet = false;
    m_SharedWithMeTime = utility::datetime();
    m_SharedWithMeTimeIsSet = false;
    m_SharingUserIsSet = false;
    m_Size = U("");
    m_SizeIsSet = false;
    m_SpacesIsSet = false;
    m_Starred = false;
    m_StarredIsSet = false;
    m_TeamDriveId = U("");
    m_TeamDriveIdIsSet = false;
    m_ThumbnailLink = U("");
    m_ThumbnailLinkIsSet = false;
    m_ThumbnailVersion = U("");
    m_ThumbnailVersionIsSet = false;
    m_Trashed = false;
    m_TrashedIsSet = false;
    m_TrashedTime = utility::datetime();
    m_TrashedTimeIsSet = false;
    m_TrashingUserIsSet = false;
    m_Version = U("");
    m_VersionIsSet = false;
    m_VideoMediaMetadataIsSet = false;
    m_ViewedByMe = false;
    m_ViewedByMeIsSet = false;
    m_ViewedByMeTime = utility::datetime();
    m_ViewedByMeTimeIsSet = false;
    m_ViewersCanCopyContent = false;
    m_ViewersCanCopyContentIsSet = false;
    m_WebContentLink = U("");
    m_WebContentLinkIsSet = false;
    m_WebViewLink = U("");
    m_WebViewLinkIsSet = false;
    m_WritersCanShare = false;
    m_WritersCanShareIsSet = false;
}

File::~File()
{
}

void File::validate()
{
    // TODO: implement validation
}

web::json::value File::toJson() const
{
    web::json::value val = web::json::value::object();

    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_AppProperties )
        {
            web::json::value tmp = web::json::value::object();
            tmp[U("key")] = ModelBase::toJson(item.first);
            tmp[U("value")] = ModelBase::toJson(item.second);
            jsonArray.push_back(tmp);
        }
        if(jsonArray.size() > 0)
        {
            val[U("appProperties")] = web::json::value::array(jsonArray);
        }
    }
    if(m_CapabilitiesIsSet)
    {
        val[U("capabilities")] = ModelBase::toJson(m_Capabilities);
    }
    if(m_ContentHintsIsSet)
    {
        val[U("contentHints")] = ModelBase::toJson(m_ContentHints);
    }
    if(m_CreatedTimeIsSet)
    {
        val[U("createdTime")] = ModelBase::toJson(m_CreatedTime);
    }
    if(m_DescriptionIsSet)
    {
        val[U("description")] = ModelBase::toJson(m_Description);
    }
    if(m_ExplicitlyTrashedIsSet)
    {
        val[U("explicitlyTrashed")] = ModelBase::toJson(m_ExplicitlyTrashed);
    }
    if(m_FileExtensionIsSet)
    {
        val[U("fileExtension")] = ModelBase::toJson(m_FileExtension);
    }
    if(m_FolderColorRgbIsSet)
    {
        val[U("folderColorRgb")] = ModelBase::toJson(m_FolderColorRgb);
    }
    if(m_FullFileExtensionIsSet)
    {
        val[U("fullFileExtension")] = ModelBase::toJson(m_FullFileExtension);
    }
    if(m_HasAugmentedPermissionsIsSet)
    {
        val[U("hasAugmentedPermissions")] = ModelBase::toJson(m_HasAugmentedPermissions);
    }
    if(m_HasThumbnailIsSet)
    {
        val[U("hasThumbnail")] = ModelBase::toJson(m_HasThumbnail);
    }
    if(m_HeadRevisionIdIsSet)
    {
        val[U("headRevisionId")] = ModelBase::toJson(m_HeadRevisionId);
    }
    if(m_IconLinkIsSet)
    {
        val[U("iconLink")] = ModelBase::toJson(m_IconLink);
    }
    if(m_IdIsSet)
    {
        val[U("id")] = ModelBase::toJson(m_Id);
    }
    if(m_ImageMediaMetadataIsSet)
    {
        val[U("imageMediaMetadata")] = ModelBase::toJson(m_ImageMediaMetadata);
    }
    if(m_IsAppAuthorizedIsSet)
    {
        val[U("isAppAuthorized")] = ModelBase::toJson(m_IsAppAuthorized);
    }
    if(m_KindIsSet)
    {
        val[U("kind")] = ModelBase::toJson(m_Kind);
    }
    if(m_LastModifyingUserIsSet)
    {
        val[U("lastModifyingUser")] = ModelBase::toJson(m_LastModifyingUser);
    }
    if(m_Md5ChecksumIsSet)
    {
        val[U("md5Checksum")] = ModelBase::toJson(m_Md5Checksum);
    }
    if(m_MimeTypeIsSet)
    {
        val[U("mimeType")] = ModelBase::toJson(m_MimeType);
    }
    if(m_ModifiedByMeIsSet)
    {
        val[U("modifiedByMe")] = ModelBase::toJson(m_ModifiedByMe);
    }
    if(m_ModifiedByMeTimeIsSet)
    {
        val[U("modifiedByMeTime")] = ModelBase::toJson(m_ModifiedByMeTime);
    }
    if(m_ModifiedTimeIsSet)
    {
        val[U("modifiedTime")] = ModelBase::toJson(m_ModifiedTime);
    }
    if(m_NameIsSet)
    {
        val[U("name")] = ModelBase::toJson(m_Name);
    }
    if(m_OriginalFilenameIsSet)
    {
        val[U("originalFilename")] = ModelBase::toJson(m_OriginalFilename);
    }
    if(m_OwnedByMeIsSet)
    {
        val[U("ownedByMe")] = ModelBase::toJson(m_OwnedByMe);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Owners )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("owners")] = web::json::value::array(jsonArray);
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Parents )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("parents")] = web::json::value::array(jsonArray);
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_PermissionIds )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("permissionIds")] = web::json::value::array(jsonArray);
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Permissions )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("permissions")] = web::json::value::array(jsonArray);
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Properties )
        {
            web::json::value tmp = web::json::value::object();
            tmp[U("key")] = ModelBase::toJson(item.first);
            tmp[U("value")] = ModelBase::toJson(item.second);
            jsonArray.push_back(tmp);
        }
        if(jsonArray.size() > 0)
        {
            val[U("properties")] = web::json::value::array(jsonArray);
        }
    }
    if(m_QuotaBytesUsedIsSet)
    {
        val[U("quotaBytesUsed")] = ModelBase::toJson(m_QuotaBytesUsed);
    }
    if(m_SharedIsSet)
    {
        val[U("shared")] = ModelBase::toJson(m_Shared);
    }
    if(m_SharedWithMeTimeIsSet)
    {
        val[U("sharedWithMeTime")] = ModelBase::toJson(m_SharedWithMeTime);
    }
    if(m_SharingUserIsSet)
    {
        val[U("sharingUser")] = ModelBase::toJson(m_SharingUser);
    }
    if(m_SizeIsSet)
    {
        val[U("size")] = ModelBase::toJson(m_Size);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Spaces )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("spaces")] = web::json::value::array(jsonArray);
        }
    }
    if(m_StarredIsSet)
    {
        val[U("starred")] = ModelBase::toJson(m_Starred);
    }
    if(m_TeamDriveIdIsSet)
    {
        val[U("teamDriveId")] = ModelBase::toJson(m_TeamDriveId);
    }
    if(m_ThumbnailLinkIsSet)
    {
        val[U("thumbnailLink")] = ModelBase::toJson(m_ThumbnailLink);
    }
    if(m_ThumbnailVersionIsSet)
    {
        val[U("thumbnailVersion")] = ModelBase::toJson(m_ThumbnailVersion);
    }
    if(m_TrashedIsSet)
    {
        val[U("trashed")] = ModelBase::toJson(m_Trashed);
    }
    if(m_TrashedTimeIsSet)
    {
        val[U("trashedTime")] = ModelBase::toJson(m_TrashedTime);
    }
    if(m_TrashingUserIsSet)
    {
        val[U("trashingUser")] = ModelBase::toJson(m_TrashingUser);
    }
    if(m_VersionIsSet)
    {
        val[U("version")] = ModelBase::toJson(m_Version);
    }
    if(m_VideoMediaMetadataIsSet)
    {
        val[U("videoMediaMetadata")] = ModelBase::toJson(m_VideoMediaMetadata);
    }
    if(m_ViewedByMeIsSet)
    {
        val[U("viewedByMe")] = ModelBase::toJson(m_ViewedByMe);
    }
    if(m_ViewedByMeTimeIsSet)
    {
        val[U("viewedByMeTime")] = ModelBase::toJson(m_ViewedByMeTime);
    }
    if(m_ViewersCanCopyContentIsSet)
    {
        val[U("viewersCanCopyContent")] = ModelBase::toJson(m_ViewersCanCopyContent);
    }
    if(m_WebContentLinkIsSet)
    {
        val[U("webContentLink")] = ModelBase::toJson(m_WebContentLink);
    }
    if(m_WebViewLinkIsSet)
    {
        val[U("webViewLink")] = ModelBase::toJson(m_WebViewLink);
    }
    if(m_WritersCanShareIsSet)
    {
        val[U("writersCanShare")] = ModelBase::toJson(m_WritersCanShare);
    }

    return val;
}

void File::fromJson(web::json::value& val)
{
    {
        m_AppProperties.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("appProperties")))
        {
        for( auto& item : val[U("appProperties")].as_array() )
        {  
            utility::string_t key;
            if(item.has_field(U("key")))
            {
                key = ModelBase::stringFromJson(item[U("key")]);
            }
            m_AppProperties.insert(std::pair<utility::string_t,utility::string_t>( key, ModelBase::stringFromJson(item[U("value")])));
        }
        }
    }
    if(val.has_field(U("capabilities")))
    {
        if(!val[U("capabilities")].is_null())
        {
            std::shared_ptr<File_capabilities> newItem(new File_capabilities());
            newItem->fromJson(val[U("capabilities")]);
            setCapabilities( newItem );
        }
    }
    if(val.has_field(U("contentHints")))
    {
        if(!val[U("contentHints")].is_null())
        {
            std::shared_ptr<File_contentHints> newItem(new File_contentHints());
            newItem->fromJson(val[U("contentHints")]);
            setContentHints( newItem );
        }
    }
    if(val.has_field(U("createdTime")))
    {
        setCreatedTime(ModelBase::dateFromJson(val[U("createdTime")]));
    }
    if(val.has_field(U("description")))
    {
        setDescription(ModelBase::stringFromJson(val[U("description")]));
    }
    if(val.has_field(U("explicitlyTrashed")))
    {
        setExplicitlyTrashed(ModelBase::boolFromJson(val[U("explicitlyTrashed")]));
    }
    if(val.has_field(U("fileExtension")))
    {
        setFileExtension(ModelBase::stringFromJson(val[U("fileExtension")]));
    }
    if(val.has_field(U("folderColorRgb")))
    {
        setFolderColorRgb(ModelBase::stringFromJson(val[U("folderColorRgb")]));
    }
    if(val.has_field(U("fullFileExtension")))
    {
        setFullFileExtension(ModelBase::stringFromJson(val[U("fullFileExtension")]));
    }
    if(val.has_field(U("hasAugmentedPermissions")))
    {
        setHasAugmentedPermissions(ModelBase::boolFromJson(val[U("hasAugmentedPermissions")]));
    }
    if(val.has_field(U("hasThumbnail")))
    {
        setHasThumbnail(ModelBase::boolFromJson(val[U("hasThumbnail")]));
    }
    if(val.has_field(U("headRevisionId")))
    {
        setHeadRevisionId(ModelBase::stringFromJson(val[U("headRevisionId")]));
    }
    if(val.has_field(U("iconLink")))
    {
        setIconLink(ModelBase::stringFromJson(val[U("iconLink")]));
    }
    if(val.has_field(U("id")))
    {
        setId(ModelBase::stringFromJson(val[U("id")]));
    }
    if(val.has_field(U("imageMediaMetadata")))
    {
        if(!val[U("imageMediaMetadata")].is_null())
        {
            std::shared_ptr<File_imageMediaMetadata> newItem(new File_imageMediaMetadata());
            newItem->fromJson(val[U("imageMediaMetadata")]);
            setImageMediaMetadata( newItem );
        }
    }
    if(val.has_field(U("isAppAuthorized")))
    {
        setIsAppAuthorized(ModelBase::boolFromJson(val[U("isAppAuthorized")]));
    }
    if(val.has_field(U("kind")))
    {
        setKind(ModelBase::stringFromJson(val[U("kind")]));
    }
    if(val.has_field(U("lastModifyingUser")))
    {
        if(!val[U("lastModifyingUser")].is_null())
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromJson(val[U("lastModifyingUser")]);
            setLastModifyingUser( newItem );
        }
    }
    if(val.has_field(U("md5Checksum")))
    {
        setMd5Checksum(ModelBase::stringFromJson(val[U("md5Checksum")]));
    }
    if(val.has_field(U("mimeType")))
    {
        setMimeType(ModelBase::stringFromJson(val[U("mimeType")]));
    }
    if(val.has_field(U("modifiedByMe")))
    {
        setModifiedByMe(ModelBase::boolFromJson(val[U("modifiedByMe")]));
    }
    if(val.has_field(U("modifiedByMeTime")))
    {
        setModifiedByMeTime(ModelBase::dateFromJson(val[U("modifiedByMeTime")]));
    }
    if(val.has_field(U("modifiedTime")))
    {
        setModifiedTime(ModelBase::dateFromJson(val[U("modifiedTime")]));
    }
    if(val.has_field(U("name")))
    {
        setName(ModelBase::stringFromJson(val[U("name")]));
    }
    if(val.has_field(U("originalFilename")))
    {
        setOriginalFilename(ModelBase::stringFromJson(val[U("originalFilename")]));
    }
    if(val.has_field(U("ownedByMe")))
    {
        setOwnedByMe(ModelBase::boolFromJson(val[U("ownedByMe")]));
    }
    {
        m_Owners.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("owners")))
        {
        for( auto& item : val[U("owners")].as_array() )
        {
            if(item.is_null())
            {
                m_Owners.push_back( std::shared_ptr<User>(nullptr) );
            }
            else
            {
                std::shared_ptr<User> newItem(new User());
                newItem->fromJson(item);
                m_Owners.push_back( newItem );
            }
        }
        }
    }
    {
        m_Parents.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("parents")))
        {
        for( auto& item : val[U("parents")].as_array() )
        {
            m_Parents.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_PermissionIds.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("permissionIds")))
        {
        for( auto& item : val[U("permissionIds")].as_array() )
        {
            m_PermissionIds.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_Permissions.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("permissions")))
        {
        for( auto& item : val[U("permissions")].as_array() )
        {
            if(item.is_null())
            {
                m_Permissions.push_back( std::shared_ptr<Permission>(nullptr) );
            }
            else
            {
                std::shared_ptr<Permission> newItem(new Permission());
                newItem->fromJson(item);
                m_Permissions.push_back( newItem );
            }
        }
        }
    }
    {
        m_Properties.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("properties")))
        {
        for( auto& item : val[U("properties")].as_array() )
        {  
            utility::string_t key;
            if(item.has_field(U("key")))
            {
                key = ModelBase::stringFromJson(item[U("key")]);
            }
            m_Properties.insert(std::pair<utility::string_t,utility::string_t>( key, ModelBase::stringFromJson(item[U("value")])));
        }
        }
    }
    if(val.has_field(U("quotaBytesUsed")))
    {
        setQuotaBytesUsed(ModelBase::stringFromJson(val[U("quotaBytesUsed")]));
    }
    if(val.has_field(U("shared")))
    {
        setShared(ModelBase::boolFromJson(val[U("shared")]));
    }
    if(val.has_field(U("sharedWithMeTime")))
    {
        setSharedWithMeTime(ModelBase::dateFromJson(val[U("sharedWithMeTime")]));
    }
    if(val.has_field(U("sharingUser")))
    {
        if(!val[U("sharingUser")].is_null())
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromJson(val[U("sharingUser")]);
            setSharingUser( newItem );
        }
    }
    if(val.has_field(U("size")))
    {
        setSize(ModelBase::stringFromJson(val[U("size")]));
    }
    {
        m_Spaces.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("spaces")))
        {
        for( auto& item : val[U("spaces")].as_array() )
        {
            m_Spaces.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    if(val.has_field(U("starred")))
    {
        setStarred(ModelBase::boolFromJson(val[U("starred")]));
    }
    if(val.has_field(U("teamDriveId")))
    {
        setTeamDriveId(ModelBase::stringFromJson(val[U("teamDriveId")]));
    }
    if(val.has_field(U("thumbnailLink")))
    {
        setThumbnailLink(ModelBase::stringFromJson(val[U("thumbnailLink")]));
    }
    if(val.has_field(U("thumbnailVersion")))
    {
        setThumbnailVersion(ModelBase::stringFromJson(val[U("thumbnailVersion")]));
    }
    if(val.has_field(U("trashed")))
    {
        setTrashed(ModelBase::boolFromJson(val[U("trashed")]));
    }
    if(val.has_field(U("trashedTime")))
    {
        setTrashedTime(ModelBase::dateFromJson(val[U("trashedTime")]));
    }
    if(val.has_field(U("trashingUser")))
    {
        if(!val[U("trashingUser")].is_null())
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromJson(val[U("trashingUser")]);
            setTrashingUser( newItem );
        }
    }
    if(val.has_field(U("version")))
    {
        setVersion(ModelBase::stringFromJson(val[U("version")]));
    }
    if(val.has_field(U("videoMediaMetadata")))
    {
        if(!val[U("videoMediaMetadata")].is_null())
        {
            std::shared_ptr<File_videoMediaMetadata> newItem(new File_videoMediaMetadata());
            newItem->fromJson(val[U("videoMediaMetadata")]);
            setVideoMediaMetadata( newItem );
        }
    }
    if(val.has_field(U("viewedByMe")))
    {
        setViewedByMe(ModelBase::boolFromJson(val[U("viewedByMe")]));
    }
    if(val.has_field(U("viewedByMeTime")))
    {
        setViewedByMeTime(ModelBase::dateFromJson(val[U("viewedByMeTime")]));
    }
    if(val.has_field(U("viewersCanCopyContent")))
    {
        setViewersCanCopyContent(ModelBase::boolFromJson(val[U("viewersCanCopyContent")]));
    }
    if(val.has_field(U("webContentLink")))
    {
        setWebContentLink(ModelBase::stringFromJson(val[U("webContentLink")]));
    }
    if(val.has_field(U("webViewLink")))
    {
        setWebViewLink(ModelBase::stringFromJson(val[U("webViewLink")]));
    }
    if(val.has_field(U("writersCanShare")))
    {
        setWritersCanShare(ModelBase::boolFromJson(val[U("writersCanShare")]));
    }
}

void File::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_AppProperties )
        {
            web::json::value tmp = web::json::value::object();
            tmp[U("key")] = ModelBase::toJson(item.first);
            tmp[U("value")] = ModelBase::toJson(item.second);
            jsonArray.push_back(tmp);
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("appProperties"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_CapabilitiesIsSet)
    {
        if (m_Capabilities.get())
        {
            m_Capabilities->toMultipart(multipart, U("capabilities."));
        }
        
    }
    if(m_ContentHintsIsSet)
    {
        if (m_ContentHints.get())
        {
            m_ContentHints->toMultipart(multipart, U("contentHints."));
        }
        
    }
    if(m_CreatedTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("createdTime"), m_CreatedTime));
        
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("description"), m_Description));
        
    }
    if(m_ExplicitlyTrashedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("explicitlyTrashed"), m_ExplicitlyTrashed));
    }
    if(m_FileExtensionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("fileExtension"), m_FileExtension));
        
    }
    if(m_FolderColorRgbIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("folderColorRgb"), m_FolderColorRgb));
        
    }
    if(m_FullFileExtensionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("fullFileExtension"), m_FullFileExtension));
        
    }
    if(m_HasAugmentedPermissionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("hasAugmentedPermissions"), m_HasAugmentedPermissions));
    }
    if(m_HasThumbnailIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("hasThumbnail"), m_HasThumbnail));
    }
    if(m_HeadRevisionIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("headRevisionId"), m_HeadRevisionId));
        
    }
    if(m_IconLinkIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("iconLink"), m_IconLink));
        
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("id"), m_Id));
        
    }
    if(m_ImageMediaMetadataIsSet)
    {
        if (m_ImageMediaMetadata.get())
        {
            m_ImageMediaMetadata->toMultipart(multipart, U("imageMediaMetadata."));
        }
        
    }
    if(m_IsAppAuthorizedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("isAppAuthorized"), m_IsAppAuthorized));
    }
    if(m_KindIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("kind"), m_Kind));
        
    }
    if(m_LastModifyingUserIsSet)
    {
        if (m_LastModifyingUser.get())
        {
            m_LastModifyingUser->toMultipart(multipart, U("lastModifyingUser."));
        }
        
    }
    if(m_Md5ChecksumIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("md5Checksum"), m_Md5Checksum));
        
    }
    if(m_MimeTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("mimeType"), m_MimeType));
        
    }
    if(m_ModifiedByMeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("modifiedByMe"), m_ModifiedByMe));
    }
    if(m_ModifiedByMeTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("modifiedByMeTime"), m_ModifiedByMeTime));
        
    }
    if(m_ModifiedTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("modifiedTime"), m_ModifiedTime));
        
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("name"), m_Name));
        
    }
    if(m_OriginalFilenameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("originalFilename"), m_OriginalFilename));
        
    }
    if(m_OwnedByMeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("ownedByMe"), m_OwnedByMe));
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Owners )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("owners"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Parents )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("parents"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_PermissionIds )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("permissionIds"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Permissions )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("permissions"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Properties )
        {
            web::json::value tmp = web::json::value::object();
            tmp[U("key")] = ModelBase::toJson(item.first);
            tmp[U("value")] = ModelBase::toJson(item.second);
            jsonArray.push_back(tmp);
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("properties"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_QuotaBytesUsedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("quotaBytesUsed"), m_QuotaBytesUsed));
        
    }
    if(m_SharedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("shared"), m_Shared));
    }
    if(m_SharedWithMeTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("sharedWithMeTime"), m_SharedWithMeTime));
        
    }
    if(m_SharingUserIsSet)
    {
        if (m_SharingUser.get())
        {
            m_SharingUser->toMultipart(multipart, U("sharingUser."));
        }
        
    }
    if(m_SizeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("size"), m_Size));
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Spaces )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("spaces"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_StarredIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("starred"), m_Starred));
    }
    if(m_TeamDriveIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("teamDriveId"), m_TeamDriveId));
        
    }
    if(m_ThumbnailLinkIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("thumbnailLink"), m_ThumbnailLink));
        
    }
    if(m_ThumbnailVersionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("thumbnailVersion"), m_ThumbnailVersion));
        
    }
    if(m_TrashedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("trashed"), m_Trashed));
    }
    if(m_TrashedTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("trashedTime"), m_TrashedTime));
        
    }
    if(m_TrashingUserIsSet)
    {
        if (m_TrashingUser.get())
        {
            m_TrashingUser->toMultipart(multipart, U("trashingUser."));
        }
        
    }
    if(m_VersionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("version"), m_Version));
        
    }
    if(m_VideoMediaMetadataIsSet)
    {
        if (m_VideoMediaMetadata.get())
        {
            m_VideoMediaMetadata->toMultipart(multipart, U("videoMediaMetadata."));
        }
        
    }
    if(m_ViewedByMeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("viewedByMe"), m_ViewedByMe));
    }
    if(m_ViewedByMeTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("viewedByMeTime"), m_ViewedByMeTime));
        
    }
    if(m_ViewersCanCopyContentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("viewersCanCopyContent"), m_ViewersCanCopyContent));
    }
    if(m_WebContentLinkIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("webContentLink"), m_WebContentLink));
        
    }
    if(m_WebViewLinkIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("webViewLink"), m_WebViewLink));
        
    }
    if(m_WritersCanShareIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("writersCanShare"), m_WritersCanShare));
    }
}

void File::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    {
        m_AppProperties.clear();
        if(multipart->hasContent(U("appProperties")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("appProperties"))));
        for( auto& item : jsonArray.as_array() )
        {
            utility::string_t key;
            if(item.has_field(U("key")))
            {
                key = ModelBase::stringFromJson(item[U("key")]);
            }
            m_AppProperties.insert(std::pair<utility::string_t,utility::string_t>( key, ModelBase::stringFromJson(item[U("value")])));
        }
        }
    }
    if(multipart->hasContent(U("capabilities")))
    {
        if(multipart->hasContent(U("capabilities")))
        {
            std::shared_ptr<File_capabilities> newItem(new File_capabilities());
            newItem->fromMultiPart(multipart, U("capabilities."));
            setCapabilities( newItem );
        }
    }
    if(multipart->hasContent(U("contentHints")))
    {
        if(multipart->hasContent(U("contentHints")))
        {
            std::shared_ptr<File_contentHints> newItem(new File_contentHints());
            newItem->fromMultiPart(multipart, U("contentHints."));
            setContentHints( newItem );
        }
    }
    if(multipart->hasContent(U("createdTime")))
    {
        setCreatedTime(ModelBase::dateFromHttpContent(multipart->getContent(U("createdTime"))));
    }
    if(multipart->hasContent(U("description")))
    {
        setDescription(ModelBase::stringFromHttpContent(multipart->getContent(U("description"))));
    }
    if(multipart->hasContent(U("explicitlyTrashed")))
    {
        setExplicitlyTrashed(ModelBase::boolFromHttpContent(multipart->getContent(U("explicitlyTrashed"))));
    }
    if(multipart->hasContent(U("fileExtension")))
    {
        setFileExtension(ModelBase::stringFromHttpContent(multipart->getContent(U("fileExtension"))));
    }
    if(multipart->hasContent(U("folderColorRgb")))
    {
        setFolderColorRgb(ModelBase::stringFromHttpContent(multipart->getContent(U("folderColorRgb"))));
    }
    if(multipart->hasContent(U("fullFileExtension")))
    {
        setFullFileExtension(ModelBase::stringFromHttpContent(multipart->getContent(U("fullFileExtension"))));
    }
    if(multipart->hasContent(U("hasAugmentedPermissions")))
    {
        setHasAugmentedPermissions(ModelBase::boolFromHttpContent(multipart->getContent(U("hasAugmentedPermissions"))));
    }
    if(multipart->hasContent(U("hasThumbnail")))
    {
        setHasThumbnail(ModelBase::boolFromHttpContent(multipart->getContent(U("hasThumbnail"))));
    }
    if(multipart->hasContent(U("headRevisionId")))
    {
        setHeadRevisionId(ModelBase::stringFromHttpContent(multipart->getContent(U("headRevisionId"))));
    }
    if(multipart->hasContent(U("iconLink")))
    {
        setIconLink(ModelBase::stringFromHttpContent(multipart->getContent(U("iconLink"))));
    }
    if(multipart->hasContent(U("id")))
    {
        setId(ModelBase::stringFromHttpContent(multipart->getContent(U("id"))));
    }
    if(multipart->hasContent(U("imageMediaMetadata")))
    {
        if(multipart->hasContent(U("imageMediaMetadata")))
        {
            std::shared_ptr<File_imageMediaMetadata> newItem(new File_imageMediaMetadata());
            newItem->fromMultiPart(multipart, U("imageMediaMetadata."));
            setImageMediaMetadata( newItem );
        }
    }
    if(multipart->hasContent(U("isAppAuthorized")))
    {
        setIsAppAuthorized(ModelBase::boolFromHttpContent(multipart->getContent(U("isAppAuthorized"))));
    }
    if(multipart->hasContent(U("kind")))
    {
        setKind(ModelBase::stringFromHttpContent(multipart->getContent(U("kind"))));
    }
    if(multipart->hasContent(U("lastModifyingUser")))
    {
        if(multipart->hasContent(U("lastModifyingUser")))
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromMultiPart(multipart, U("lastModifyingUser."));
            setLastModifyingUser( newItem );
        }
    }
    if(multipart->hasContent(U("md5Checksum")))
    {
        setMd5Checksum(ModelBase::stringFromHttpContent(multipart->getContent(U("md5Checksum"))));
    }
    if(multipart->hasContent(U("mimeType")))
    {
        setMimeType(ModelBase::stringFromHttpContent(multipart->getContent(U("mimeType"))));
    }
    if(multipart->hasContent(U("modifiedByMe")))
    {
        setModifiedByMe(ModelBase::boolFromHttpContent(multipart->getContent(U("modifiedByMe"))));
    }
    if(multipart->hasContent(U("modifiedByMeTime")))
    {
        setModifiedByMeTime(ModelBase::dateFromHttpContent(multipart->getContent(U("modifiedByMeTime"))));
    }
    if(multipart->hasContent(U("modifiedTime")))
    {
        setModifiedTime(ModelBase::dateFromHttpContent(multipart->getContent(U("modifiedTime"))));
    }
    if(multipart->hasContent(U("name")))
    {
        setName(ModelBase::stringFromHttpContent(multipart->getContent(U("name"))));
    }
    if(multipart->hasContent(U("originalFilename")))
    {
        setOriginalFilename(ModelBase::stringFromHttpContent(multipart->getContent(U("originalFilename"))));
    }
    if(multipart->hasContent(U("ownedByMe")))
    {
        setOwnedByMe(ModelBase::boolFromHttpContent(multipart->getContent(U("ownedByMe"))));
    }
    {
        m_Owners.clear();
        if(multipart->hasContent(U("owners")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("owners"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_Owners.push_back( std::shared_ptr<User>(nullptr) );
            }
            else
            {
                std::shared_ptr<User> newItem(new User());
                newItem->fromJson(item);
                m_Owners.push_back( newItem );
            }
        }
        }
    }
    {
        m_Parents.clear();
        if(multipart->hasContent(U("parents")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("parents"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_Parents.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_PermissionIds.clear();
        if(multipart->hasContent(U("permissionIds")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("permissionIds"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_PermissionIds.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_Permissions.clear();
        if(multipart->hasContent(U("permissions")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("permissions"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_Permissions.push_back( std::shared_ptr<Permission>(nullptr) );
            }
            else
            {
                std::shared_ptr<Permission> newItem(new Permission());
                newItem->fromJson(item);
                m_Permissions.push_back( newItem );
            }
        }
        }
    }
    {
        m_Properties.clear();
        if(multipart->hasContent(U("properties")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("properties"))));
        for( auto& item : jsonArray.as_array() )
        {
            utility::string_t key;
            if(item.has_field(U("key")))
            {
                key = ModelBase::stringFromJson(item[U("key")]);
            }
            m_Properties.insert(std::pair<utility::string_t,utility::string_t>( key, ModelBase::stringFromJson(item[U("value")])));
        }
        }
    }
    if(multipart->hasContent(U("quotaBytesUsed")))
    {
        setQuotaBytesUsed(ModelBase::stringFromHttpContent(multipart->getContent(U("quotaBytesUsed"))));
    }
    if(multipart->hasContent(U("shared")))
    {
        setShared(ModelBase::boolFromHttpContent(multipart->getContent(U("shared"))));
    }
    if(multipart->hasContent(U("sharedWithMeTime")))
    {
        setSharedWithMeTime(ModelBase::dateFromHttpContent(multipart->getContent(U("sharedWithMeTime"))));
    }
    if(multipart->hasContent(U("sharingUser")))
    {
        if(multipart->hasContent(U("sharingUser")))
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromMultiPart(multipart, U("sharingUser."));
            setSharingUser( newItem );
        }
    }
    if(multipart->hasContent(U("size")))
    {
        setSize(ModelBase::stringFromHttpContent(multipart->getContent(U("size"))));
    }
    {
        m_Spaces.clear();
        if(multipart->hasContent(U("spaces")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("spaces"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_Spaces.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    if(multipart->hasContent(U("starred")))
    {
        setStarred(ModelBase::boolFromHttpContent(multipart->getContent(U("starred"))));
    }
    if(multipart->hasContent(U("teamDriveId")))
    {
        setTeamDriveId(ModelBase::stringFromHttpContent(multipart->getContent(U("teamDriveId"))));
    }
    if(multipart->hasContent(U("thumbnailLink")))
    {
        setThumbnailLink(ModelBase::stringFromHttpContent(multipart->getContent(U("thumbnailLink"))));
    }
    if(multipart->hasContent(U("thumbnailVersion")))
    {
        setThumbnailVersion(ModelBase::stringFromHttpContent(multipart->getContent(U("thumbnailVersion"))));
    }
    if(multipart->hasContent(U("trashed")))
    {
        setTrashed(ModelBase::boolFromHttpContent(multipart->getContent(U("trashed"))));
    }
    if(multipart->hasContent(U("trashedTime")))
    {
        setTrashedTime(ModelBase::dateFromHttpContent(multipart->getContent(U("trashedTime"))));
    }
    if(multipart->hasContent(U("trashingUser")))
    {
        if(multipart->hasContent(U("trashingUser")))
        {
            std::shared_ptr<User> newItem(new User());
            newItem->fromMultiPart(multipart, U("trashingUser."));
            setTrashingUser( newItem );
        }
    }
    if(multipart->hasContent(U("version")))
    {
        setVersion(ModelBase::stringFromHttpContent(multipart->getContent(U("version"))));
    }
    if(multipart->hasContent(U("videoMediaMetadata")))
    {
        if(multipart->hasContent(U("videoMediaMetadata")))
        {
            std::shared_ptr<File_videoMediaMetadata> newItem(new File_videoMediaMetadata());
            newItem->fromMultiPart(multipart, U("videoMediaMetadata."));
            setVideoMediaMetadata( newItem );
        }
    }
    if(multipart->hasContent(U("viewedByMe")))
    {
        setViewedByMe(ModelBase::boolFromHttpContent(multipart->getContent(U("viewedByMe"))));
    }
    if(multipart->hasContent(U("viewedByMeTime")))
    {
        setViewedByMeTime(ModelBase::dateFromHttpContent(multipart->getContent(U("viewedByMeTime"))));
    }
    if(multipart->hasContent(U("viewersCanCopyContent")))
    {
        setViewersCanCopyContent(ModelBase::boolFromHttpContent(multipart->getContent(U("viewersCanCopyContent"))));
    }
    if(multipart->hasContent(U("webContentLink")))
    {
        setWebContentLink(ModelBase::stringFromHttpContent(multipart->getContent(U("webContentLink"))));
    }
    if(multipart->hasContent(U("webViewLink")))
    {
        setWebViewLink(ModelBase::stringFromHttpContent(multipart->getContent(U("webViewLink"))));
    }
    if(multipart->hasContent(U("writersCanShare")))
    {
        setWritersCanShare(ModelBase::boolFromHttpContent(multipart->getContent(U("writersCanShare"))));
    }
}

std::map<utility::string_t, utility::string_t>& File::getAppProperties()
{
    return m_AppProperties;
}

void File::setAppProperties(std::map<utility::string_t, utility::string_t> value)
{
    m_AppProperties = value;
    m_AppPropertiesIsSet = true;
}
bool File::appPropertiesIsSet() const
{
    return m_AppPropertiesIsSet;
}

void File::unsetAppProperties()
{
    m_AppPropertiesIsSet = false;
}

std::shared_ptr<File_capabilities> File::getCapabilities() const
{
    return m_Capabilities;
}


void File::setCapabilities(std::shared_ptr<File_capabilities> value)
{
    m_Capabilities = value;
    m_CapabilitiesIsSet = true;
}
bool File::capabilitiesIsSet() const
{
    return m_CapabilitiesIsSet;
}

void File::unsetCapabilities()
{
    m_CapabilitiesIsSet = false;
}

std::shared_ptr<File_contentHints> File::getContentHints() const
{
    return m_ContentHints;
}


void File::setContentHints(std::shared_ptr<File_contentHints> value)
{
    m_ContentHints = value;
    m_ContentHintsIsSet = true;
}
bool File::contentHintsIsSet() const
{
    return m_ContentHintsIsSet;
}

void File::unsetContentHints()
{
    m_ContentHintsIsSet = false;
}

utility::datetime File::getCreatedTime() const
{
    return m_CreatedTime;
}


void File::setCreatedTime(utility::datetime value)
{
    m_CreatedTime = value;
    m_CreatedTimeIsSet = true;
}
bool File::createdTimeIsSet() const
{
    return m_CreatedTimeIsSet;
}

void File::unsetCreatedTime()
{
    m_CreatedTimeIsSet = false;
}

utility::string_t File::getDescription() const
{
    return m_Description;
}


void File::setDescription(utility::string_t value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}
bool File::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void File::unsetDescription()
{
    m_DescriptionIsSet = false;
}

bool File::getExplicitlyTrashed() const
{
    return m_ExplicitlyTrashed;
}


void File::setExplicitlyTrashed(bool value)
{
    m_ExplicitlyTrashed = value;
    m_ExplicitlyTrashedIsSet = true;
}
bool File::explicitlyTrashedIsSet() const
{
    return m_ExplicitlyTrashedIsSet;
}

void File::unsetExplicitlyTrashed()
{
    m_ExplicitlyTrashedIsSet = false;
}

utility::string_t File::getFileExtension() const
{
    return m_FileExtension;
}


void File::setFileExtension(utility::string_t value)
{
    m_FileExtension = value;
    m_FileExtensionIsSet = true;
}
bool File::fileExtensionIsSet() const
{
    return m_FileExtensionIsSet;
}

void File::unsetFileExtension()
{
    m_FileExtensionIsSet = false;
}

utility::string_t File::getFolderColorRgb() const
{
    return m_FolderColorRgb;
}


void File::setFolderColorRgb(utility::string_t value)
{
    m_FolderColorRgb = value;
    m_FolderColorRgbIsSet = true;
}
bool File::folderColorRgbIsSet() const
{
    return m_FolderColorRgbIsSet;
}

void File::unsetFolderColorRgb()
{
    m_FolderColorRgbIsSet = false;
}

utility::string_t File::getFullFileExtension() const
{
    return m_FullFileExtension;
}


void File::setFullFileExtension(utility::string_t value)
{
    m_FullFileExtension = value;
    m_FullFileExtensionIsSet = true;
}
bool File::fullFileExtensionIsSet() const
{
    return m_FullFileExtensionIsSet;
}

void File::unsetFullFileExtension()
{
    m_FullFileExtensionIsSet = false;
}

bool File::getHasAugmentedPermissions() const
{
    return m_HasAugmentedPermissions;
}


void File::setHasAugmentedPermissions(bool value)
{
    m_HasAugmentedPermissions = value;
    m_HasAugmentedPermissionsIsSet = true;
}
bool File::hasAugmentedPermissionsIsSet() const
{
    return m_HasAugmentedPermissionsIsSet;
}

void File::unsetHasAugmentedPermissions()
{
    m_HasAugmentedPermissionsIsSet = false;
}

bool File::getHasThumbnail() const
{
    return m_HasThumbnail;
}


void File::setHasThumbnail(bool value)
{
    m_HasThumbnail = value;
    m_HasThumbnailIsSet = true;
}
bool File::hasThumbnailIsSet() const
{
    return m_HasThumbnailIsSet;
}

void File::unsetHasThumbnail()
{
    m_HasThumbnailIsSet = false;
}

utility::string_t File::getHeadRevisionId() const
{
    return m_HeadRevisionId;
}


void File::setHeadRevisionId(utility::string_t value)
{
    m_HeadRevisionId = value;
    m_HeadRevisionIdIsSet = true;
}
bool File::headRevisionIdIsSet() const
{
    return m_HeadRevisionIdIsSet;
}

void File::unsetHeadRevisionId()
{
    m_HeadRevisionIdIsSet = false;
}

utility::string_t File::getIconLink() const
{
    return m_IconLink;
}


void File::setIconLink(utility::string_t value)
{
    m_IconLink = value;
    m_IconLinkIsSet = true;
}
bool File::iconLinkIsSet() const
{
    return m_IconLinkIsSet;
}

void File::unsetIconLink()
{
    m_IconLinkIsSet = false;
}

utility::string_t File::getId() const
{
    return m_Id;
}


void File::setId(utility::string_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}
bool File::idIsSet() const
{
    return m_IdIsSet;
}

void File::unsetId()
{
    m_IdIsSet = false;
}

std::shared_ptr<File_imageMediaMetadata> File::getImageMediaMetadata() const
{
    return m_ImageMediaMetadata;
}


void File::setImageMediaMetadata(std::shared_ptr<File_imageMediaMetadata> value)
{
    m_ImageMediaMetadata = value;
    m_ImageMediaMetadataIsSet = true;
}
bool File::imageMediaMetadataIsSet() const
{
    return m_ImageMediaMetadataIsSet;
}

void File::unsetImageMediaMetadata()
{
    m_ImageMediaMetadataIsSet = false;
}

bool File::getIsAppAuthorized() const
{
    return m_IsAppAuthorized;
}


void File::setIsAppAuthorized(bool value)
{
    m_IsAppAuthorized = value;
    m_IsAppAuthorizedIsSet = true;
}
bool File::isAppAuthorizedIsSet() const
{
    return m_IsAppAuthorizedIsSet;
}

void File::unsetIsAppAuthorized()
{
    m_IsAppAuthorizedIsSet = false;
}

utility::string_t File::getKind() const
{
    return m_Kind;
}


void File::setKind(utility::string_t value)
{
    m_Kind = value;
    m_KindIsSet = true;
}
bool File::kindIsSet() const
{
    return m_KindIsSet;
}

void File::unsetKind()
{
    m_KindIsSet = false;
}

std::shared_ptr<User> File::getLastModifyingUser() const
{
    return m_LastModifyingUser;
}


void File::setLastModifyingUser(std::shared_ptr<User> value)
{
    m_LastModifyingUser = value;
    m_LastModifyingUserIsSet = true;
}
bool File::lastModifyingUserIsSet() const
{
    return m_LastModifyingUserIsSet;
}

void File::unsetLastModifyingUser()
{
    m_LastModifyingUserIsSet = false;
}

utility::string_t File::getMd5Checksum() const
{
    return m_Md5Checksum;
}


void File::setMd5Checksum(utility::string_t value)
{
    m_Md5Checksum = value;
    m_Md5ChecksumIsSet = true;
}
bool File::md5ChecksumIsSet() const
{
    return m_Md5ChecksumIsSet;
}

void File::unsetMd5Checksum()
{
    m_Md5ChecksumIsSet = false;
}

utility::string_t File::getMimeType() const
{
    return m_MimeType;
}


void File::setMimeType(utility::string_t value)
{
    m_MimeType = value;
    m_MimeTypeIsSet = true;
}
bool File::mimeTypeIsSet() const
{
    return m_MimeTypeIsSet;
}

void File::unsetMimeType()
{
    m_MimeTypeIsSet = false;
}

bool File::getModifiedByMe() const
{
    return m_ModifiedByMe;
}


void File::setModifiedByMe(bool value)
{
    m_ModifiedByMe = value;
    m_ModifiedByMeIsSet = true;
}
bool File::modifiedByMeIsSet() const
{
    return m_ModifiedByMeIsSet;
}

void File::unsetModifiedByMe()
{
    m_ModifiedByMeIsSet = false;
}

utility::datetime File::getModifiedByMeTime() const
{
    return m_ModifiedByMeTime;
}


void File::setModifiedByMeTime(utility::datetime value)
{
    m_ModifiedByMeTime = value;
    m_ModifiedByMeTimeIsSet = true;
}
bool File::modifiedByMeTimeIsSet() const
{
    return m_ModifiedByMeTimeIsSet;
}

void File::unsetModifiedByMeTime()
{
    m_ModifiedByMeTimeIsSet = false;
}

utility::datetime File::getModifiedTime() const
{
    return m_ModifiedTime;
}


void File::setModifiedTime(utility::datetime value)
{
    m_ModifiedTime = value;
    m_ModifiedTimeIsSet = true;
}
bool File::modifiedTimeIsSet() const
{
    return m_ModifiedTimeIsSet;
}

void File::unsetModifiedTime()
{
    m_ModifiedTimeIsSet = false;
}

utility::string_t File::getName() const
{
    return m_Name;
}


void File::setName(utility::string_t value)
{
    m_Name = value;
    m_NameIsSet = true;
}
bool File::nameIsSet() const
{
    return m_NameIsSet;
}

void File::unsetName()
{
    m_NameIsSet = false;
}

utility::string_t File::getOriginalFilename() const
{
    return m_OriginalFilename;
}


void File::setOriginalFilename(utility::string_t value)
{
    m_OriginalFilename = value;
    m_OriginalFilenameIsSet = true;
}
bool File::originalFilenameIsSet() const
{
    return m_OriginalFilenameIsSet;
}

void File::unsetOriginalFilename()
{
    m_OriginalFilenameIsSet = false;
}

bool File::getOwnedByMe() const
{
    return m_OwnedByMe;
}


void File::setOwnedByMe(bool value)
{
    m_OwnedByMe = value;
    m_OwnedByMeIsSet = true;
}
bool File::ownedByMeIsSet() const
{
    return m_OwnedByMeIsSet;
}

void File::unsetOwnedByMe()
{
    m_OwnedByMeIsSet = false;
}

std::vector<std::shared_ptr<User>>& File::getOwners()
{
    return m_Owners;
}

void File::setOwners(std::vector<std::shared_ptr<User>> value)
{
    m_Owners = value;
    m_OwnersIsSet = true;
}
bool File::ownersIsSet() const
{
    return m_OwnersIsSet;
}

void File::unsetOwners()
{
    m_OwnersIsSet = false;
}

std::vector<utility::string_t>& File::getParents()
{
    return m_Parents;
}

void File::setParents(std::vector<utility::string_t> value)
{
    m_Parents = value;
    m_ParentsIsSet = true;
}
bool File::parentsIsSet() const
{
    return m_ParentsIsSet;
}

void File::unsetParents()
{
    m_ParentsIsSet = false;
}

std::vector<utility::string_t>& File::getPermissionIds()
{
    return m_PermissionIds;
}

void File::setPermissionIds(std::vector<utility::string_t> value)
{
    m_PermissionIds = value;
    m_PermissionIdsIsSet = true;
}
bool File::permissionIdsIsSet() const
{
    return m_PermissionIdsIsSet;
}

void File::unsetPermissionIds()
{
    m_PermissionIdsIsSet = false;
}

std::vector<std::shared_ptr<Permission>>& File::getPermissions()
{
    return m_Permissions;
}

void File::setPermissions(std::vector<std::shared_ptr<Permission>> value)
{
    m_Permissions = value;
    m_PermissionsIsSet = true;
}
bool File::permissionsIsSet() const
{
    return m_PermissionsIsSet;
}

void File::unsetPermissions()
{
    m_PermissionsIsSet = false;
}

std::map<utility::string_t, utility::string_t>& File::getProperties()
{
    return m_Properties;
}

void File::setProperties(std::map<utility::string_t, utility::string_t> value)
{
    m_Properties = value;
    m_PropertiesIsSet = true;
}
bool File::propertiesIsSet() const
{
    return m_PropertiesIsSet;
}

void File::unsetProperties()
{
    m_PropertiesIsSet = false;
}

utility::string_t File::getQuotaBytesUsed() const
{
    return m_QuotaBytesUsed;
}


void File::setQuotaBytesUsed(utility::string_t value)
{
    m_QuotaBytesUsed = value;
    m_QuotaBytesUsedIsSet = true;
}
bool File::quotaBytesUsedIsSet() const
{
    return m_QuotaBytesUsedIsSet;
}

void File::unsetQuotaBytesUsed()
{
    m_QuotaBytesUsedIsSet = false;
}

bool File::getShared() const
{
    return m_Shared;
}


void File::setShared(bool value)
{
    m_Shared = value;
    m_SharedIsSet = true;
}
bool File::sharedIsSet() const
{
    return m_SharedIsSet;
}

void File::unsetShared()
{
    m_SharedIsSet = false;
}

utility::datetime File::getSharedWithMeTime() const
{
    return m_SharedWithMeTime;
}


void File::setSharedWithMeTime(utility::datetime value)
{
    m_SharedWithMeTime = value;
    m_SharedWithMeTimeIsSet = true;
}
bool File::sharedWithMeTimeIsSet() const
{
    return m_SharedWithMeTimeIsSet;
}

void File::unsetSharedWithMeTime()
{
    m_SharedWithMeTimeIsSet = false;
}

std::shared_ptr<User> File::getSharingUser() const
{
    return m_SharingUser;
}


void File::setSharingUser(std::shared_ptr<User> value)
{
    m_SharingUser = value;
    m_SharingUserIsSet = true;
}
bool File::sharingUserIsSet() const
{
    return m_SharingUserIsSet;
}

void File::unsetSharingUser()
{
    m_SharingUserIsSet = false;
}

utility::string_t File::getSize() const
{
    return m_Size;
}


void File::setSize(utility::string_t value)
{
    m_Size = value;
    m_SizeIsSet = true;
}
bool File::sizeIsSet() const
{
    return m_SizeIsSet;
}

void File::unsetSize()
{
    m_SizeIsSet = false;
}

std::vector<utility::string_t>& File::getSpaces()
{
    return m_Spaces;
}

void File::setSpaces(std::vector<utility::string_t> value)
{
    m_Spaces = value;
    m_SpacesIsSet = true;
}
bool File::spacesIsSet() const
{
    return m_SpacesIsSet;
}

void File::unsetSpaces()
{
    m_SpacesIsSet = false;
}

bool File::getStarred() const
{
    return m_Starred;
}


void File::setStarred(bool value)
{
    m_Starred = value;
    m_StarredIsSet = true;
}
bool File::starredIsSet() const
{
    return m_StarredIsSet;
}

void File::unsetStarred()
{
    m_StarredIsSet = false;
}

utility::string_t File::getTeamDriveId() const
{
    return m_TeamDriveId;
}


void File::setTeamDriveId(utility::string_t value)
{
    m_TeamDriveId = value;
    m_TeamDriveIdIsSet = true;
}
bool File::teamDriveIdIsSet() const
{
    return m_TeamDriveIdIsSet;
}

void File::unsetTeamDriveId()
{
    m_TeamDriveIdIsSet = false;
}

utility::string_t File::getThumbnailLink() const
{
    return m_ThumbnailLink;
}


void File::setThumbnailLink(utility::string_t value)
{
    m_ThumbnailLink = value;
    m_ThumbnailLinkIsSet = true;
}
bool File::thumbnailLinkIsSet() const
{
    return m_ThumbnailLinkIsSet;
}

void File::unsetThumbnailLink()
{
    m_ThumbnailLinkIsSet = false;
}

utility::string_t File::getThumbnailVersion() const
{
    return m_ThumbnailVersion;
}


void File::setThumbnailVersion(utility::string_t value)
{
    m_ThumbnailVersion = value;
    m_ThumbnailVersionIsSet = true;
}
bool File::thumbnailVersionIsSet() const
{
    return m_ThumbnailVersionIsSet;
}

void File::unsetThumbnailVersion()
{
    m_ThumbnailVersionIsSet = false;
}

bool File::getTrashed() const
{
    return m_Trashed;
}


void File::setTrashed(bool value)
{
    m_Trashed = value;
    m_TrashedIsSet = true;
}
bool File::trashedIsSet() const
{
    return m_TrashedIsSet;
}

void File::unsetTrashed()
{
    m_TrashedIsSet = false;
}

utility::datetime File::getTrashedTime() const
{
    return m_TrashedTime;
}


void File::setTrashedTime(utility::datetime value)
{
    m_TrashedTime = value;
    m_TrashedTimeIsSet = true;
}
bool File::trashedTimeIsSet() const
{
    return m_TrashedTimeIsSet;
}

void File::unsetTrashedTime()
{
    m_TrashedTimeIsSet = false;
}

std::shared_ptr<User> File::getTrashingUser() const
{
    return m_TrashingUser;
}


void File::setTrashingUser(std::shared_ptr<User> value)
{
    m_TrashingUser = value;
    m_TrashingUserIsSet = true;
}
bool File::trashingUserIsSet() const
{
    return m_TrashingUserIsSet;
}

void File::unsetTrashingUser()
{
    m_TrashingUserIsSet = false;
}

utility::string_t File::getVersion() const
{
    return m_Version;
}


void File::setVersion(utility::string_t value)
{
    m_Version = value;
    m_VersionIsSet = true;
}
bool File::versionIsSet() const
{
    return m_VersionIsSet;
}

void File::unsetVersion()
{
    m_VersionIsSet = false;
}

std::shared_ptr<File_videoMediaMetadata> File::getVideoMediaMetadata() const
{
    return m_VideoMediaMetadata;
}


void File::setVideoMediaMetadata(std::shared_ptr<File_videoMediaMetadata> value)
{
    m_VideoMediaMetadata = value;
    m_VideoMediaMetadataIsSet = true;
}
bool File::videoMediaMetadataIsSet() const
{
    return m_VideoMediaMetadataIsSet;
}

void File::unsetVideoMediaMetadata()
{
    m_VideoMediaMetadataIsSet = false;
}

bool File::getViewedByMe() const
{
    return m_ViewedByMe;
}


void File::setViewedByMe(bool value)
{
    m_ViewedByMe = value;
    m_ViewedByMeIsSet = true;
}
bool File::viewedByMeIsSet() const
{
    return m_ViewedByMeIsSet;
}

void File::unsetViewedByMe()
{
    m_ViewedByMeIsSet = false;
}

utility::datetime File::getViewedByMeTime() const
{
    return m_ViewedByMeTime;
}


void File::setViewedByMeTime(utility::datetime value)
{
    m_ViewedByMeTime = value;
    m_ViewedByMeTimeIsSet = true;
}
bool File::viewedByMeTimeIsSet() const
{
    return m_ViewedByMeTimeIsSet;
}

void File::unsetViewedByMeTime()
{
    m_ViewedByMeTimeIsSet = false;
}

bool File::getViewersCanCopyContent() const
{
    return m_ViewersCanCopyContent;
}


void File::setViewersCanCopyContent(bool value)
{
    m_ViewersCanCopyContent = value;
    m_ViewersCanCopyContentIsSet = true;
}
bool File::viewersCanCopyContentIsSet() const
{
    return m_ViewersCanCopyContentIsSet;
}

void File::unsetViewersCanCopyContent()
{
    m_ViewersCanCopyContentIsSet = false;
}

utility::string_t File::getWebContentLink() const
{
    return m_WebContentLink;
}


void File::setWebContentLink(utility::string_t value)
{
    m_WebContentLink = value;
    m_WebContentLinkIsSet = true;
}
bool File::webContentLinkIsSet() const
{
    return m_WebContentLinkIsSet;
}

void File::unsetWebContentLink()
{
    m_WebContentLinkIsSet = false;
}

utility::string_t File::getWebViewLink() const
{
    return m_WebViewLink;
}


void File::setWebViewLink(utility::string_t value)
{
    m_WebViewLink = value;
    m_WebViewLinkIsSet = true;
}
bool File::webViewLinkIsSet() const
{
    return m_WebViewLinkIsSet;
}

void File::unsetWebViewLink()
{
    m_WebViewLinkIsSet = false;
}

bool File::getWritersCanShare() const
{
    return m_WritersCanShare;
}


void File::setWritersCanShare(bool value)
{
    m_WritersCanShare = value;
    m_WritersCanShareIsSet = true;
}
bool File::writersCanShareIsSet() const
{
    return m_WritersCanShareIsSet;
}

void File::unsetWritersCanShare()
{
    m_WritersCanShareIsSet = false;
}

}
}
}
}


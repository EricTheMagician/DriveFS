/**
 * Drive
 * Manages files in Drive including uploading, downloading, searching, detecting changes, and updating sharing permissions.
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.2.3.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "File_imageMediaMetadata.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

File_imageMediaMetadata::File_imageMediaMetadata()
{
    m_Aperture = 0.0f;
    m_ApertureIsSet = false;
    m_CameraMake = U("");
    m_CameraMakeIsSet = false;
    m_CameraModel = U("");
    m_CameraModelIsSet = false;
    m_ColorSpace = U("");
    m_ColorSpaceIsSet = false;
    m_ExposureBias = 0.0f;
    m_ExposureBiasIsSet = false;
    m_ExposureMode = U("");
    m_ExposureModeIsSet = false;
    m_ExposureTime = 0.0f;
    m_ExposureTimeIsSet = false;
    m_FlashUsed = false;
    m_FlashUsedIsSet = false;
    m_FocalLength = 0.0f;
    m_FocalLengthIsSet = false;
    m_Height = 0;
    m_HeightIsSet = false;
    m_IsoSpeed = 0;
    m_IsoSpeedIsSet = false;
    m_Lens = U("");
    m_LensIsSet = false;
    m_LocationIsSet = false;
    m_MaxApertureValue = 0.0f;
    m_MaxApertureValueIsSet = false;
    m_MeteringMode = U("");
    m_MeteringModeIsSet = false;
    m_Rotation = 0;
    m_RotationIsSet = false;
    m_Sensor = U("");
    m_SensorIsSet = false;
    m_SubjectDistance = 0;
    m_SubjectDistanceIsSet = false;
    m_Time = U("");
    m_TimeIsSet = false;
    m_WhiteBalance = U("");
    m_WhiteBalanceIsSet = false;
    m_Width = 0;
    m_WidthIsSet = false;
}

File_imageMediaMetadata::~File_imageMediaMetadata()
{
}

void File_imageMediaMetadata::validate()
{
    // TODO: implement validation
}

web::json::value File_imageMediaMetadata::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_ApertureIsSet)
    {
        val[U("aperture")] = ModelBase::toJson(m_Aperture);
    }
    if(m_CameraMakeIsSet)
    {
        val[U("cameraMake")] = ModelBase::toJson(m_CameraMake);
    }
    if(m_CameraModelIsSet)
    {
        val[U("cameraModel")] = ModelBase::toJson(m_CameraModel);
    }
    if(m_ColorSpaceIsSet)
    {
        val[U("colorSpace")] = ModelBase::toJson(m_ColorSpace);
    }
    if(m_ExposureBiasIsSet)
    {
        val[U("exposureBias")] = ModelBase::toJson(m_ExposureBias);
    }
    if(m_ExposureModeIsSet)
    {
        val[U("exposureMode")] = ModelBase::toJson(m_ExposureMode);
    }
    if(m_ExposureTimeIsSet)
    {
        val[U("exposureTime")] = ModelBase::toJson(m_ExposureTime);
    }
    if(m_FlashUsedIsSet)
    {
        val[U("flashUsed")] = ModelBase::toJson(m_FlashUsed);
    }
    if(m_FocalLengthIsSet)
    {
        val[U("focalLength")] = ModelBase::toJson(m_FocalLength);
    }
    if(m_HeightIsSet)
    {
        val[U("height")] = ModelBase::toJson(m_Height);
    }
    if(m_IsoSpeedIsSet)
    {
        val[U("isoSpeed")] = ModelBase::toJson(m_IsoSpeed);
    }
    if(m_LensIsSet)
    {
        val[U("lens")] = ModelBase::toJson(m_Lens);
    }
    if(m_LocationIsSet)
    {
        val[U("location")] = ModelBase::toJson(m_Location);
    }
    if(m_MaxApertureValueIsSet)
    {
        val[U("maxApertureValue")] = ModelBase::toJson(m_MaxApertureValue);
    }
    if(m_MeteringModeIsSet)
    {
        val[U("meteringMode")] = ModelBase::toJson(m_MeteringMode);
    }
    if(m_RotationIsSet)
    {
        val[U("rotation")] = ModelBase::toJson(m_Rotation);
    }
    if(m_SensorIsSet)
    {
        val[U("sensor")] = ModelBase::toJson(m_Sensor);
    }
    if(m_SubjectDistanceIsSet)
    {
        val[U("subjectDistance")] = ModelBase::toJson(m_SubjectDistance);
    }
    if(m_TimeIsSet)
    {
        val[U("time")] = ModelBase::toJson(m_Time);
    }
    if(m_WhiteBalanceIsSet)
    {
        val[U("whiteBalance")] = ModelBase::toJson(m_WhiteBalance);
    }
    if(m_WidthIsSet)
    {
        val[U("width")] = ModelBase::toJson(m_Width);
    }

    return val;
}

void File_imageMediaMetadata::fromJson(web::json::value& val)
{
    if(val.has_field(U("aperture")))
    {
        setAperture(ModelBase::floatFromJson(val[U("aperture")]));
    }
    if(val.has_field(U("cameraMake")))
    {
        setCameraMake(ModelBase::stringFromJson(val[U("cameraMake")]));
    }
    if(val.has_field(U("cameraModel")))
    {
        setCameraModel(ModelBase::stringFromJson(val[U("cameraModel")]));
    }
    if(val.has_field(U("colorSpace")))
    {
        setColorSpace(ModelBase::stringFromJson(val[U("colorSpace")]));
    }
    if(val.has_field(U("exposureBias")))
    {
        setExposureBias(ModelBase::floatFromJson(val[U("exposureBias")]));
    }
    if(val.has_field(U("exposureMode")))
    {
        setExposureMode(ModelBase::stringFromJson(val[U("exposureMode")]));
    }
    if(val.has_field(U("exposureTime")))
    {
        setExposureTime(ModelBase::floatFromJson(val[U("exposureTime")]));
    }
    if(val.has_field(U("flashUsed")))
    {
        setFlashUsed(ModelBase::boolFromJson(val[U("flashUsed")]));
    }
    if(val.has_field(U("focalLength")))
    {
        setFocalLength(ModelBase::floatFromJson(val[U("focalLength")]));
    }
    if(val.has_field(U("height")))
    {
        setHeight(ModelBase::int32_tFromJson(val[U("height")]));
    }
    if(val.has_field(U("isoSpeed")))
    {
        setIsoSpeed(ModelBase::int32_tFromJson(val[U("isoSpeed")]));
    }
    if(val.has_field(U("lens")))
    {
        setLens(ModelBase::stringFromJson(val[U("lens")]));
    }
    if(val.has_field(U("location")))
    {
        if(!val[U("location")].is_null())
        {
            std::shared_ptr<File_imageMediaMetadata_location> newItem(new File_imageMediaMetadata_location());
            newItem->fromJson(val[U("location")]);
            setLocation( newItem );
        }
    }
    if(val.has_field(U("maxApertureValue")))
    {
        setMaxApertureValue(ModelBase::floatFromJson(val[U("maxApertureValue")]));
    }
    if(val.has_field(U("meteringMode")))
    {
        setMeteringMode(ModelBase::stringFromJson(val[U("meteringMode")]));
    }
    if(val.has_field(U("rotation")))
    {
        setRotation(ModelBase::int32_tFromJson(val[U("rotation")]));
    }
    if(val.has_field(U("sensor")))
    {
        setSensor(ModelBase::stringFromJson(val[U("sensor")]));
    }
    if(val.has_field(U("subjectDistance")))
    {
        setSubjectDistance(ModelBase::int32_tFromJson(val[U("subjectDistance")]));
    }
    if(val.has_field(U("time")))
    {
        setTime(ModelBase::stringFromJson(val[U("time")]));
    }
    if(val.has_field(U("whiteBalance")))
    {
        setWhiteBalance(ModelBase::stringFromJson(val[U("whiteBalance")]));
    }
    if(val.has_field(U("width")))
    {
        setWidth(ModelBase::int32_tFromJson(val[U("width")]));
    }
}

void File_imageMediaMetadata::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(m_ApertureIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("aperture"), m_Aperture));
    }
    if(m_CameraMakeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("cameraMake"), m_CameraMake));
        
    }
    if(m_CameraModelIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("cameraModel"), m_CameraModel));
        
    }
    if(m_ColorSpaceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("colorSpace"), m_ColorSpace));
        
    }
    if(m_ExposureBiasIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("exposureBias"), m_ExposureBias));
    }
    if(m_ExposureModeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("exposureMode"), m_ExposureMode));
        
    }
    if(m_ExposureTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("exposureTime"), m_ExposureTime));
    }
    if(m_FlashUsedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("flashUsed"), m_FlashUsed));
    }
    if(m_FocalLengthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("focalLength"), m_FocalLength));
    }
    if(m_HeightIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("height"), m_Height));
    }
    if(m_IsoSpeedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("isoSpeed"), m_IsoSpeed));
    }
    if(m_LensIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("lens"), m_Lens));
        
    }
    if(m_LocationIsSet)
    {
        if (m_Location.get())
        {
            m_Location->toMultipart(multipart, U("location."));
        }
        
    }
    if(m_MaxApertureValueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("maxApertureValue"), m_MaxApertureValue));
    }
    if(m_MeteringModeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("meteringMode"), m_MeteringMode));
        
    }
    if(m_RotationIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("rotation"), m_Rotation));
    }
    if(m_SensorIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("sensor"), m_Sensor));
        
    }
    if(m_SubjectDistanceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("subjectDistance"), m_SubjectDistance));
    }
    if(m_TimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("time"), m_Time));
        
    }
    if(m_WhiteBalanceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("whiteBalance"), m_WhiteBalance));
        
    }
    if(m_WidthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("width"), m_Width));
    }
}

void File_imageMediaMetadata::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(multipart->hasContent(U("aperture")))
    {
        setAperture(ModelBase::floatFromHttpContent(multipart->getContent(U("aperture"))));
    }
    if(multipart->hasContent(U("cameraMake")))
    {
        setCameraMake(ModelBase::stringFromHttpContent(multipart->getContent(U("cameraMake"))));
    }
    if(multipart->hasContent(U("cameraModel")))
    {
        setCameraModel(ModelBase::stringFromHttpContent(multipart->getContent(U("cameraModel"))));
    }
    if(multipart->hasContent(U("colorSpace")))
    {
        setColorSpace(ModelBase::stringFromHttpContent(multipart->getContent(U("colorSpace"))));
    }
    if(multipart->hasContent(U("exposureBias")))
    {
        setExposureBias(ModelBase::floatFromHttpContent(multipart->getContent(U("exposureBias"))));
    }
    if(multipart->hasContent(U("exposureMode")))
    {
        setExposureMode(ModelBase::stringFromHttpContent(multipart->getContent(U("exposureMode"))));
    }
    if(multipart->hasContent(U("exposureTime")))
    {
        setExposureTime(ModelBase::floatFromHttpContent(multipart->getContent(U("exposureTime"))));
    }
    if(multipart->hasContent(U("flashUsed")))
    {
        setFlashUsed(ModelBase::boolFromHttpContent(multipart->getContent(U("flashUsed"))));
    }
    if(multipart->hasContent(U("focalLength")))
    {
        setFocalLength(ModelBase::floatFromHttpContent(multipart->getContent(U("focalLength"))));
    }
    if(multipart->hasContent(U("height")))
    {
        setHeight(ModelBase::int32_tFromHttpContent(multipart->getContent(U("height"))));
    }
    if(multipart->hasContent(U("isoSpeed")))
    {
        setIsoSpeed(ModelBase::int32_tFromHttpContent(multipart->getContent(U("isoSpeed"))));
    }
    if(multipart->hasContent(U("lens")))
    {
        setLens(ModelBase::stringFromHttpContent(multipart->getContent(U("lens"))));
    }
    if(multipart->hasContent(U("location")))
    {
        if(multipart->hasContent(U("location")))
        {
            std::shared_ptr<File_imageMediaMetadata_location> newItem(new File_imageMediaMetadata_location());
            newItem->fromMultiPart(multipart, U("location."));
            setLocation( newItem );
        }
    }
    if(multipart->hasContent(U("maxApertureValue")))
    {
        setMaxApertureValue(ModelBase::floatFromHttpContent(multipart->getContent(U("maxApertureValue"))));
    }
    if(multipart->hasContent(U("meteringMode")))
    {
        setMeteringMode(ModelBase::stringFromHttpContent(multipart->getContent(U("meteringMode"))));
    }
    if(multipart->hasContent(U("rotation")))
    {
        setRotation(ModelBase::int32_tFromHttpContent(multipart->getContent(U("rotation"))));
    }
    if(multipart->hasContent(U("sensor")))
    {
        setSensor(ModelBase::stringFromHttpContent(multipart->getContent(U("sensor"))));
    }
    if(multipart->hasContent(U("subjectDistance")))
    {
        setSubjectDistance(ModelBase::int32_tFromHttpContent(multipart->getContent(U("subjectDistance"))));
    }
    if(multipart->hasContent(U("time")))
    {
        setTime(ModelBase::stringFromHttpContent(multipart->getContent(U("time"))));
    }
    if(multipart->hasContent(U("whiteBalance")))
    {
        setWhiteBalance(ModelBase::stringFromHttpContent(multipart->getContent(U("whiteBalance"))));
    }
    if(multipart->hasContent(U("width")))
    {
        setWidth(ModelBase::int32_tFromHttpContent(multipart->getContent(U("width"))));
    }
}

float File_imageMediaMetadata::getAperture() const
{
    return m_Aperture;
}


void File_imageMediaMetadata::setAperture(float value)
{
    m_Aperture = value;
    m_ApertureIsSet = true;
}
bool File_imageMediaMetadata::apertureIsSet() const
{
    return m_ApertureIsSet;
}

void File_imageMediaMetadata::unsetAperture()
{
    m_ApertureIsSet = false;
}

utility::string_t File_imageMediaMetadata::getCameraMake() const
{
    return m_CameraMake;
}


void File_imageMediaMetadata::setCameraMake(utility::string_t value)
{
    m_CameraMake = value;
    m_CameraMakeIsSet = true;
}
bool File_imageMediaMetadata::cameraMakeIsSet() const
{
    return m_CameraMakeIsSet;
}

void File_imageMediaMetadata::unsetCameraMake()
{
    m_CameraMakeIsSet = false;
}

utility::string_t File_imageMediaMetadata::getCameraModel() const
{
    return m_CameraModel;
}


void File_imageMediaMetadata::setCameraModel(utility::string_t value)
{
    m_CameraModel = value;
    m_CameraModelIsSet = true;
}
bool File_imageMediaMetadata::cameraModelIsSet() const
{
    return m_CameraModelIsSet;
}

void File_imageMediaMetadata::unsetCameraModel()
{
    m_CameraModelIsSet = false;
}

utility::string_t File_imageMediaMetadata::getColorSpace() const
{
    return m_ColorSpace;
}


void File_imageMediaMetadata::setColorSpace(utility::string_t value)
{
    m_ColorSpace = value;
    m_ColorSpaceIsSet = true;
}
bool File_imageMediaMetadata::colorSpaceIsSet() const
{
    return m_ColorSpaceIsSet;
}

void File_imageMediaMetadata::unsetColorSpace()
{
    m_ColorSpaceIsSet = false;
}

float File_imageMediaMetadata::getExposureBias() const
{
    return m_ExposureBias;
}


void File_imageMediaMetadata::setExposureBias(float value)
{
    m_ExposureBias = value;
    m_ExposureBiasIsSet = true;
}
bool File_imageMediaMetadata::exposureBiasIsSet() const
{
    return m_ExposureBiasIsSet;
}

void File_imageMediaMetadata::unsetExposureBias()
{
    m_ExposureBiasIsSet = false;
}

utility::string_t File_imageMediaMetadata::getExposureMode() const
{
    return m_ExposureMode;
}


void File_imageMediaMetadata::setExposureMode(utility::string_t value)
{
    m_ExposureMode = value;
    m_ExposureModeIsSet = true;
}
bool File_imageMediaMetadata::exposureModeIsSet() const
{
    return m_ExposureModeIsSet;
}

void File_imageMediaMetadata::unsetExposureMode()
{
    m_ExposureModeIsSet = false;
}

float File_imageMediaMetadata::getExposureTime() const
{
    return m_ExposureTime;
}


void File_imageMediaMetadata::setExposureTime(float value)
{
    m_ExposureTime = value;
    m_ExposureTimeIsSet = true;
}
bool File_imageMediaMetadata::exposureTimeIsSet() const
{
    return m_ExposureTimeIsSet;
}

void File_imageMediaMetadata::unsetExposureTime()
{
    m_ExposureTimeIsSet = false;
}

bool File_imageMediaMetadata::getFlashUsed() const
{
    return m_FlashUsed;
}


void File_imageMediaMetadata::setFlashUsed(bool value)
{
    m_FlashUsed = value;
    m_FlashUsedIsSet = true;
}
bool File_imageMediaMetadata::flashUsedIsSet() const
{
    return m_FlashUsedIsSet;
}

void File_imageMediaMetadata::unsetFlashUsed()
{
    m_FlashUsedIsSet = false;
}

float File_imageMediaMetadata::getFocalLength() const
{
    return m_FocalLength;
}


void File_imageMediaMetadata::setFocalLength(float value)
{
    m_FocalLength = value;
    m_FocalLengthIsSet = true;
}
bool File_imageMediaMetadata::focalLengthIsSet() const
{
    return m_FocalLengthIsSet;
}

void File_imageMediaMetadata::unsetFocalLength()
{
    m_FocalLengthIsSet = false;
}

int32_t File_imageMediaMetadata::getHeight() const
{
    return m_Height;
}


void File_imageMediaMetadata::setHeight(int32_t value)
{
    m_Height = value;
    m_HeightIsSet = true;
}
bool File_imageMediaMetadata::heightIsSet() const
{
    return m_HeightIsSet;
}

void File_imageMediaMetadata::unsetHeight()
{
    m_HeightIsSet = false;
}

int32_t File_imageMediaMetadata::getIsoSpeed() const
{
    return m_IsoSpeed;
}


void File_imageMediaMetadata::setIsoSpeed(int32_t value)
{
    m_IsoSpeed = value;
    m_IsoSpeedIsSet = true;
}
bool File_imageMediaMetadata::isoSpeedIsSet() const
{
    return m_IsoSpeedIsSet;
}

void File_imageMediaMetadata::unsetIsoSpeed()
{
    m_IsoSpeedIsSet = false;
}

utility::string_t File_imageMediaMetadata::getLens() const
{
    return m_Lens;
}


void File_imageMediaMetadata::setLens(utility::string_t value)
{
    m_Lens = value;
    m_LensIsSet = true;
}
bool File_imageMediaMetadata::lensIsSet() const
{
    return m_LensIsSet;
}

void File_imageMediaMetadata::unsetLens()
{
    m_LensIsSet = false;
}

std::shared_ptr<File_imageMediaMetadata_location> File_imageMediaMetadata::getLocation() const
{
    return m_Location;
}


void File_imageMediaMetadata::setLocation(std::shared_ptr<File_imageMediaMetadata_location> value)
{
    m_Location = value;
    m_LocationIsSet = true;
}
bool File_imageMediaMetadata::locationIsSet() const
{
    return m_LocationIsSet;
}

void File_imageMediaMetadata::unsetLocation()
{
    m_LocationIsSet = false;
}

float File_imageMediaMetadata::getMaxApertureValue() const
{
    return m_MaxApertureValue;
}


void File_imageMediaMetadata::setMaxApertureValue(float value)
{
    m_MaxApertureValue = value;
    m_MaxApertureValueIsSet = true;
}
bool File_imageMediaMetadata::maxApertureValueIsSet() const
{
    return m_MaxApertureValueIsSet;
}

void File_imageMediaMetadata::unsetMaxApertureValue()
{
    m_MaxApertureValueIsSet = false;
}

utility::string_t File_imageMediaMetadata::getMeteringMode() const
{
    return m_MeteringMode;
}


void File_imageMediaMetadata::setMeteringMode(utility::string_t value)
{
    m_MeteringMode = value;
    m_MeteringModeIsSet = true;
}
bool File_imageMediaMetadata::meteringModeIsSet() const
{
    return m_MeteringModeIsSet;
}

void File_imageMediaMetadata::unsetMeteringMode()
{
    m_MeteringModeIsSet = false;
}

int32_t File_imageMediaMetadata::getRotation() const
{
    return m_Rotation;
}


void File_imageMediaMetadata::setRotation(int32_t value)
{
    m_Rotation = value;
    m_RotationIsSet = true;
}
bool File_imageMediaMetadata::rotationIsSet() const
{
    return m_RotationIsSet;
}

void File_imageMediaMetadata::unsetRotation()
{
    m_RotationIsSet = false;
}

utility::string_t File_imageMediaMetadata::getSensor() const
{
    return m_Sensor;
}


void File_imageMediaMetadata::setSensor(utility::string_t value)
{
    m_Sensor = value;
    m_SensorIsSet = true;
}
bool File_imageMediaMetadata::sensorIsSet() const
{
    return m_SensorIsSet;
}

void File_imageMediaMetadata::unsetSensor()
{
    m_SensorIsSet = false;
}

int32_t File_imageMediaMetadata::getSubjectDistance() const
{
    return m_SubjectDistance;
}


void File_imageMediaMetadata::setSubjectDistance(int32_t value)
{
    m_SubjectDistance = value;
    m_SubjectDistanceIsSet = true;
}
bool File_imageMediaMetadata::subjectDistanceIsSet() const
{
    return m_SubjectDistanceIsSet;
}

void File_imageMediaMetadata::unsetSubjectDistance()
{
    m_SubjectDistanceIsSet = false;
}

utility::string_t File_imageMediaMetadata::getTime() const
{
    return m_Time;
}


void File_imageMediaMetadata::setTime(utility::string_t value)
{
    m_Time = value;
    m_TimeIsSet = true;
}
bool File_imageMediaMetadata::timeIsSet() const
{
    return m_TimeIsSet;
}

void File_imageMediaMetadata::unsetTime()
{
    m_TimeIsSet = false;
}

utility::string_t File_imageMediaMetadata::getWhiteBalance() const
{
    return m_WhiteBalance;
}


void File_imageMediaMetadata::setWhiteBalance(utility::string_t value)
{
    m_WhiteBalance = value;
    m_WhiteBalanceIsSet = true;
}
bool File_imageMediaMetadata::whiteBalanceIsSet() const
{
    return m_WhiteBalanceIsSet;
}

void File_imageMediaMetadata::unsetWhiteBalance()
{
    m_WhiteBalanceIsSet = false;
}

int32_t File_imageMediaMetadata::getWidth() const
{
    return m_Width;
}


void File_imageMediaMetadata::setWidth(int32_t value)
{
    m_Width = value;
    m_WidthIsSet = true;
}
bool File_imageMediaMetadata::widthIsSet() const
{
    return m_WidthIsSet;
}

void File_imageMediaMetadata::unsetWidth()
{
    m_WidthIsSet = false;
}

}
}
}
}


/**
 * Drive
 * Manages files in Drive including uploading, downloading, searching, detecting changes, and updating sharing permissions.
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.2.3.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "FilesApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

FilesApi::FilesApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

FilesApi::~FilesApi()
{
}

pplx::task<std::shared_ptr<File>> FilesApi::copy(utility::string_t fileId, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, std::shared_ptr<File> body, bool ignoreDefaultVisibility, bool keepRevisionForever, utility::string_t ocrLanguage, bool supportsTeamDrives)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}/copy");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.copy does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("ignoreDefaultVisibility")] = ApiClient::parameterToString(ignoreDefaultVisibility);
    }
    
    {
        queryParams[U("keepRevisionForever")] = ApiClient::parameterToString(keepRevisionForever);
    }
    
    {
        queryParams[U("ocrLanguage")] = ApiClient::parameterToString(ocrLanguage);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.copy does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.copy: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.copy: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<File> result(new File());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.copy: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<File>> FilesApi::create(utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, std::shared_ptr<File> body, bool ignoreDefaultVisibility, bool keepRevisionForever, utility::string_t ocrLanguage, bool supportsTeamDrives, bool useContentAsIndexableText)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.create does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( U("application/octet-stream") );

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("ignoreDefaultVisibility")] = ApiClient::parameterToString(ignoreDefaultVisibility);
    }
    
    {
        queryParams[U("keepRevisionForever")] = ApiClient::parameterToString(keepRevisionForever);
    }
    
    {
        queryParams[U("ocrLanguage")] = ApiClient::parameterToString(ocrLanguage);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }
    
    {
        queryParams[U("useContentAsIndexableText")] = ApiClient::parameterToString(useContentAsIndexableText);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.create does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.create: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.create: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<File> result(new File());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.create: unsupported response type"));
        }

        return result;
    });
}
pplx::task<void> FilesApi::delete_(utility::string_t fileId, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, bool supportsTeamDrives)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.delete does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.delete does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.delete: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.delete: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> FilesApi::emptyTrash(utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/trash");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.emptyTrash does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.emptyTrash does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.emptyTrash: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.emptyTrash: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<void> FilesApi::export_(utility::string_t fileId, utility::string_t mimeType, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}/export");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.export does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("mimeType")] = ApiClient::parameterToString(mimeType);
    }
    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.export does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.export: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.export: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<GeneratedIds>> FilesApi::generateIds(utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, int32_t count, utility::string_t space)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/generateIds");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.generateIds does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("count")] = ApiClient::parameterToString(count);
    }
    
    {
        queryParams[U("space")] = ApiClient::parameterToString(space);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.generateIds does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.generateIds: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.generateIds: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<GeneratedIds> result(new GeneratedIds());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.generateIds: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<File>> FilesApi::get(utility::string_t fileId, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, bool acknowledgeAbuse, bool supportsTeamDrives)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.get does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("acknowledgeAbuse")] = ApiClient::parameterToString(acknowledgeAbuse);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.get does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.get: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.get: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<File> result(new File());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.get: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<FileList>> FilesApi::list(utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, utility::string_t corpora, utility::string_t corpus, bool includeTeamDriveItems, utility::string_t orderBy, int32_t pageSize, utility::string_t pageToken, utility::string_t q, utility::string_t spaces, bool supportsTeamDrives, utility::string_t teamDriveId)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.list does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("corpora")] = ApiClient::parameterToString(corpora);
    }
    
    {
        queryParams[U("corpus")] = ApiClient::parameterToString(corpus);
    }
    
    {
        queryParams[U("includeTeamDriveItems")] = ApiClient::parameterToString(includeTeamDriveItems);
    }
    
    {
        queryParams[U("orderBy")] = ApiClient::parameterToString(orderBy);
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
    }
    
    {
        queryParams[U("pageToken")] = ApiClient::parameterToString(pageToken);
    }
    
    {
        queryParams[U("q")] = ApiClient::parameterToString(q);
    }
    
    {
        queryParams[U("spaces")] = ApiClient::parameterToString(spaces);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }
    
    {
        queryParams[U("teamDriveId")] = ApiClient::parameterToString(teamDriveId);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.list does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.list: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.list: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<FileList> result(new FileList());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.list: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<File>> FilesApi::update(utility::string_t fileId, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, utility::string_t addParents, std::shared_ptr<File> body, bool keepRevisionForever, utility::string_t ocrLanguage, utility::string_t removeParents, bool supportsTeamDrives, bool useContentAsIndexableText)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.update does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( U("application/octet-stream") );

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("addParents")] = ApiClient::parameterToString(addParents);
    }
    
    {
        queryParams[U("keepRevisionForever")] = ApiClient::parameterToString(keepRevisionForever);
    }
    
    {
        queryParams[U("ocrLanguage")] = ApiClient::parameterToString(ocrLanguage);
    }
    
    {
        queryParams[U("removeParents")] = ApiClient::parameterToString(removeParents);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }
    
    {
        queryParams[U("useContentAsIndexableText")] = ApiClient::parameterToString(useContentAsIndexableText);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(body);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(body.get())
        {
            body->toMultipart(multipart, U("body"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.update does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("PATCH"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.update: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.update: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<File> result(new File());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.update: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Channel>> FilesApi::watch(utility::string_t fileId, utility::string_t alt, utility::string_t fields, utility::string_t key, utility::string_t oauthToken, bool prettyPrint, utility::string_t quotaUser, utility::string_t userIp, bool acknowledgeAbuse, std::shared_ptr<Channel> resource, bool supportsTeamDrives)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/files/{fileId}/watch");
    boost::replace_all(path, U("{") U("fileId") U("}"), ApiClient::parameterToString(fileId));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = U("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("FilesApi->drive.files.watch does not produce any supported media type"));
    }

    headerParams[U("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;

    
    {
        queryParams[U("alt")] = ApiClient::parameterToString(alt);
    }
    
    {
        queryParams[U("fields")] = ApiClient::parameterToString(fields);
    }
    
    {
        queryParams[U("key")] = ApiClient::parameterToString(key);
    }
    
    {
        queryParams[U("oauth_token")] = ApiClient::parameterToString(oauthToken);
    }
    
    {
        queryParams[U("prettyPrint")] = ApiClient::parameterToString(prettyPrint);
    }
    
    {
        queryParams[U("quotaUser")] = ApiClient::parameterToString(quotaUser);
    }
    
    {
        queryParams[U("userIp")] = ApiClient::parameterToString(userIp);
    }
    
    {
        queryParams[U("acknowledgeAbuse")] = ApiClient::parameterToString(acknowledgeAbuse);
    }
    
    {
        queryParams[U("supportsTeamDrives")] = ApiClient::parameterToString(supportsTeamDrives);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");
        web::json::value json;

        json = ModelBase::toJson(resource);

        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
                if(resource.get())
        {
            resource->toMultipart(multipart, U("resource"));
        }

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("FilesApi->drive.files.watch does not consume any supported media type"));
    }

    //Set the request content type in the header.
    headerParams[U("Content-Type")] = requestHttpContentType;

    // authentication (Oauth2) required
    // oauth2 authentication is added automatically as part of the http_client_config
    // authentication (Oauth2c) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling drive.files.watch: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling drive.files.watch: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Channel> result(new Channel());

        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , U("error calling drive.files.watch: unsupported response type"));
        }

        return result;
    });
}

}
}
}
}

